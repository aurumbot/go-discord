package moderation

import (
	"github.com/boltdb/bolt"
	f "github.com/whitman-colm/go-discord"
	"github.com/whitman-colm/go-discord/dat"
	"time"
)

func init() {
	now := time.Now()
	defer db.Close()

	db, err := bolt.Open(moderation.db, 0666, &bolt.Options{Timeout: 1 * time.Second})
	if err != nil {
		return
	}

	// Checks active infractions to see if any have expired.
	if err := db.Update(func(tx *bolt.Tx) error {
		b, err := tx.CreateBucket([]byte("active"))
		if err != nil {
			dat.Log.Println(err)
			return err
		}

		if err := b.ForEach(func(k, v, []byte) error {
			until, _ := time.Parse("2006-01-02@15:04:05", v.Until)
			if now.After(until) {
				reverseAction((time.Nanosecond), b, v)
				return nil
			} else {
				go reverseAction(time.Until(until), b, v)
				return nil
			}
		}); err != nil {
			dat.Log.Println(err)
			return err
		}
	}); err != nil {
		dat.Log.Println(err)
		return
	}

	// Checks un-decayed infractions to see if any have decayed.
	if err := db.Update(func(tx *bolt.Tx) error {
		b, err := tx.CreateBucket([]byte("decay"))
		if err != nil {
			dat.Log.Println(err)
			return err
		}

		if err := b.ForEach(func(k, v, []byte) error {
			until, _ := time.Parse("2006-01-02@15:04:05", v.Until)
			if now.After(until) {
				return b.Remove([]byte(k))
			}
			return nil
		}); err != nil {
			dat.Log.Println(err)
			return err
		}
	}); err != nil {
		dat.Log.Println(err)
		return
	}

}

/* Logs Moderation Actions
* Create Incident is a private function for use only in this package.
* It handles creating logs and storing them in the databases.
* The function uses the following arguments:
* - u string	: The user affected (ID)
* - a string	: The person who used moderation action (ID)
* - i .Time	: The time that the action was taken
* - e .Duration	: The duration of the action to last
* - w string	: The reason why the action was taken
* - p int	: The action that was taken (as defined by the "reason" enum)
* The function returns the following values:
* - _ error	: An error. Note that the error has already been logged to the
*		  appropriate place, this return is just in case exterior acts
*		  like alerting the discord-end users that something messed up.
*
* //NOTE: The decay time is generated internally by the bot.
* //TODO: Make decay times able to be changed in the config to be more
*	  or less harsh.
 */
func createIncident(u string, a string, g string, i time.Time, e time.Duration, w string, p int) error {
	var decay string

	if w == "" {
		w = "No reason was provided"
	}

	eP := i.Add(e)
	//TODO: Make decay make sense
	if p == 2|4 {
		//Decay is generated by the function 3âˆš(x^2) * 200 where X is
		//the length of the action in hopefully minutes.
		decay = eP.Add((((e ^ 2) ^ (1 / 3)) * 200))
	} else {
		decay = i.Add((((e ^ 2) ^ (1 / 3)) * 200))
	}

	infraction := incident{
		ID:     "", //TODO: figure out how to gen a unique id,
		User:   u,
		Issuer: a,
		Guild:  g,
		Time:   i.Format("2006-01-02@15:04:05"),
		Until:  eP.Format("2006-01-02@15:04:05"),
		Reason: w,
		Action: p,
		Decay:  decay.Format("2006-01-02@15:04:05"),
	}

	// The incident has been generated, now to store in the database
	db, err := bolt.Open(moderation.db, 0666, &bolt.Options{Timeout: 1 * time.Second})
	defer db.Close()

	if err = db.Update(func(tx *bolt.Tx) error {
		logs, err := tx.CreateBucket([]byte("logs"))
		decay, err := tx.CreateBucket([]byte("decay"))
		if err != nil {
			return err
		}

		// Store values into the logs
		if err := logs.Put([]byte(infraction.ID), []byte(infraction)); err != nil {
			return err
		}
		// Store values into the decay list
		if err := decay.Put([]byte(infraction.ID), []byte(infraction)); err != nil {
			return err
		}

		if !false { // This should be a check to see if a timed mute/ban was enacted
			return nil
		}

		// Store values into the active punishment list (timed mutes, tempbans)
		active, err := tx.CreateBucket([]byte("active"))
		if err != nil {
			return err
		}
		if err := active.Put([]byte(inf.ID), []byte(inf)); err != nil {
			return err
		}
		// Spawns off the goroutine to remove the punishment from the user.
		go reverseAction(e, active, infraction)
		return nil

	}); err != nil {
		dat.Log.Println(err)
		return err
	}
	return nil
}
