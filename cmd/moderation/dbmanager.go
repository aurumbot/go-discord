package moderation

import (
	"github.com/boltdb/bolt"
	f "github.com/whitman-colm/go-discord"
	"github.com/whitman-colm/go-discord/dat"
	"time"
)

func init() {
	now := time.Now()
	defer db.Close()

	db, err := bolt.Open(moderation.db, 0666, &bolt.Options{Timeout: 1 * time.Second})
	if err != nil {
		return
	}

	// Checks active infractions to see if any have expired.
	if err := db.Update(func(tx *bolt.Tx) error {
		b, err := tx.CreateBucket([]byte("active"))
		if err != nil {
			dat.Log.Println(err)
			return err
		}

		if err := b.ForEach(func(k, v, []byte) error {
			until, _ := time.Parse("2006-01-02@15:04:05", v.Until)
			if now.After(until) {
				reverseAction((time.Nanosecond), b, v)
				return nil
			} else {
				go reverseAction(time.Until(until), b, v)
				return nil
			}
		}); err != nil {
			dat.Log.Println(err)
			return err
		}
	}); err != nil {
		dat.Log.Println(err)
		return
	}
}

/* Logs Moderation Actions
* Create Incident is a private function for use only in this package.
* It handles creating logs and storing them in the databases.
* The function uses the following arguments:
* - u string	: The user affected (ID)
* - a string	: The person who used moderation action (ID)
* - g string	: The guild of the infraction (ID)
* - i .Time	: The time that the action was taken
* - e .Duration	: The duration of the action to last
* - w string	: The reason why the action was taken
* - p int	: The action that was taken (as defined by the "reason" enum)
* The function returns the following values:
* - _ error	: An error. Note that the error has already been logged to the
*		  appropriate place, this return is just in case exterior acts
*		  like alerting the discord-end users that something messed up.
*
* //NOTE: The decay time is generated internally by the bot.
* //TODO: Make decay times able to be changed in the config to be more
*	  or less harsh.
 */
/* NOTE: function redundant? try to remove by end.
func createIncident(u string, a string, g string, i time.Time, e time.Duration, w string, p int) error {
	if w == "" {
		w = "No reason was provided"
	}

	eP := i.Add(e)
	//TODO: Make decay make sense
	if p == 2|4 {
		//Decay is generated by the function 3âˆš(x^2) * 200 where X is
		//the length of the action in hopefully minutes.
		decay = eP.Add((((e ^ 2) ^ (1 / 3)) * 200))
	} else {
		decay = i.Add((((e ^ 2) ^ (1 / 3)) * 200))
	}Decay is being put off until it doesn't suck.

	return incident{
		ID:     "", //TODO: figure out how to gen a unique id,
		User:   u,
		Issuer: a,
		Guild:  g,
		Time:   i.Format("2006-01-02@15:04:05"),
		Until:  eP.Format("2006-01-02@15:04:05"),
		Reason: w,
		Action: p,
		//Decay:  decay.Format("2006-01-02@15:04:05"),
	}, nil
}
*/

/* The thing that logs things to the database
* log is a simple wrapper to save an infraction to the appropriate
* bolt bucket(s).
*
* Parameters:
* - inf incident{} : the incedent to be logged.
*
* Returns:
* - _ error : an error, if it came up. The error has already
*		been logged. This is just to pass to an AlertDiscord()
*
* TODO: Yeah just another reminder that when working on decay, a third bucket
*	will be needed.
 */
func log(inf incident) error {
	db, err := bolt.Open(moderation.db, 0666, &bolt.Options{Timeout: 1 * time.Second})
	defer db.Close()

	if err = db.Update(func(tx *bolt.Tx) error {
		logs, err := tx.CreateBucket([]byte("logs"))
		if err != nil {
			return err
		}

		// Store values into the logs
		if err := logs.Put([]byte(inf.ID), []byte(inf)); err != nil {
			return err
		}

		if !false { // This should be a check to see if a timed mute/ban was enacted
			return nil
		}

		// Store values into the active punishment list (timed mutes, tempbans)
		active, err := tx.CreateBucket([]byte("active"))
		if err != nil {
			return err
		}
		if err := active.Put([]byte(inf.ID), []byte(inf)); err != nil {
			return err
		}
		// Spawns off the goroutine to remove the punishment from the user.
		go reverseAction(e, active, infraction)
		return nil

	}); err != nil {
		dat.Log.Println(err)
		return err
	}
	return nil
}
