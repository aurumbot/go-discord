package mods

import (
	dsg "github.com/bwmarrin/discordgo"
	f "github.com/whitman-colm/go-discord"
	"github.com/whitman-colm/go-discord/dat"
	"github.com/whitman-colm/go-discord/flags"
	"strings"
	"time"
)

func init() {
	Commands["mute"] = &f.Command{
		Name: "Mute a user",
		Help: `Adds the muted role to the mentioned user(s).
The muted role will forbid permission to speak in text and voice channels
unless otherwise and manually changed. A reason and duration (in minutes) can
also be added with the flags:
	--duration	| time muted
	--reason	| reason muted
The muted role will be generated by the bot upon first use.
The actor must have the PermissionKickMembers perm to run this command.
Usage: mute @user --duration 5 --reason spam`,
		Action: muteUser,
	}
}

func muteUser(session *dsg.Session, message *dsg.MessageCreate) {
	s := session
	m := message

	perm, err := f.HasPermissions(s, m.Message, m.Author.ID, dsg.PermissionKickMembers)
	if err != nil {
		dat.Log.Println(err)
		dat.AlertDiscord(s, m, err)
		return
	}
	if !perm {
		s.ChannelMessageSend(m.ChannelID, "Sorry, you do not have permission to use this command.")
		return
	}

	var (
		reason   string
		duration time.Duration
	)
	flagSplit := strings.Split(message.Content, " ")
	flagsParsed := flags.Parse(flagSplit)

	for _, flag := range flagsParsed {
		if flag.Type == flags.DoubleDash && flag.Name == "reason" {
			reason = flag.Value[0]
		} else if flag.Type == flags.DoubleDash && flag.Name == "reason" {
			duration, err = time.ParseDuration(flag.Value[0])
			if err != nil {
				dat.Log.Println(err)
				dat.AlertDiscord(s, m, err)
				return
			}
		}
	}

	guild, err := f.GetGuild(s, m.Message)
	if err != nil {
		dat.Log.Println(err)
		s.ChannelMessageSend(m.ChannelID, "Error: "+err.Error())
		return
	}

	if cfg.MuteRole == "" {
		createMuteRole(guild, s, m)
	}

	for _, user := range m.Mentions {
		err := s.GuildMemberRoleAdd(guild.ID, user.ID, cfg.MuteRole)
		if err != nil {
			dat.Log.Println(err)
			s.ChannelMessageSend(m.ChannelID, "Error: "+err.Error())
		} else {
			s.ChannelMessageSend(m.ChannelID, user.Username+"#"+user.Discriminator+" (ID: "+user.ID+") has been muted.")
			createIncident(user.ID, m.Author.ID, time.Now(), duration, reason, mute)
		}
	}
}

func createMuteRole(guild *dsg.Guild, s *dsg.Session, m *dsg.MessageCreate) {
	role, err := s.GuildRoleCreate(guild.ID)
	if err != nil {
		dat.Log.Println(err)
		s.ChannelMessageSend(m.ChannelID, "Error: "+err.Error())
		return
	}
	role, err = s.GuildRoleEdit(guild.ID, role.ID, "Muted", 8487814, false, 1049664, false)
	if err != nil {
		dat.Log.Println(err)
		s.ChannelMessageSend(m.ChannelID, "Error: "+err.Error())
		return
	}
	cfg.MuteRole = role.ID
	err = dat.Save("moderation"+ps+"config.json", &cfg)
	if err != nil {
		dat.Log.Println(err)
		s.ChannelMessageSend(m.ChannelID, "Error: "+err.Error())
		return
	}
}
