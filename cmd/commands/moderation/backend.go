package mods

import (
	f "github.com/whitman-colm/go-discord"
	"github.com/whitman-colm/go-discord/dat"
	"time"
)

type config struct {
	MuteRole    string   `json:"muted"`
	BannedWords []string `json:"swears"`
}

/* Moderation logs
* The moderation package comes with built-in logs using json files as a pseudo-
* database. Each "incident" consists of the following fields:
* - ID     : The infraction ID, this is a unique id for each incident
* - User   : The ID of the user who was acted upon.
* - Issuer : The moderator who took action against the user.
* - Time   : The time the action was taken.
* - Until  : When the action ends for a temp-mute or temp-ban
* - Reason : Why the action was issued
* - Action : The ID of the action that was taken. See constants for more info
* - Decay  : Statute of limitations. Prevents the bot from being overly-harsh
*            to repeat offences with large gaps of time between infractions.
 */
type incident struct {
	ID     int    `json:"case"`
	User   string `json:"user"`
	Issuer string `json:"actor"`
	Time   string `json:"time"`
	Until  string `json:"duration"`
	Reason string `json:"reason"`
	Action int    `json:"action"`
	Decay  string `json:"decay"`
}

type modlogs struct {
	Incidents []incident `json:"incidents"`
}

// Defined enum codes for each action a moderator can take.
const (
	warn     = 0 // an official warning, no immediate action.
	delmsg   = 1 // message is deleted (censorship by bot).
	mute     = 2 // user is muted
	kick     = 3 // user is kicked
	tempban  = 4 // user is temporarily banned
	permaban = 5 // user is permanently banned
	restore  = 6 // user has their mute revoked
	pardon   = 7 // user is pardoned from a ban
)

var (
	Commands = make(map[string]*f.Command)
	ps       string
	cfg      *config
	logs     *modlogs
)

func init() {
	ps = dat.OSCheck()
	dat.Load("moderation"+ps+"config.json", &cfg)
	dat.Load("moderation"+ps+"logs.json", &logs)
}

/* Logs Moderation Actions
* Create Incident is a private function for use only in this package.
* It handles creating logs and storing them in their JSON proto-"database".
* The function uses the following arguments:
* - u string	: The user affected (ID)
* - a string	: The person who used moderation action (ID)
* - i .Time	: The time that the action was taken
* - e .Duration	: The duration of the action
* - w string	: The reason why the action was taken
* - p int	: The action that was taken (as defined by the constants above)
* The function returns the following values:
* - _ error	: An error. Note that the error has already been logged to the
*		  appropriate place, this return is just in case exterior acts
*		  like alerting the discord-end users that something messed up.
*
* //TODO: I swear I should be using pointers but it breaks the append function.
* //NOTE: The decay time is generated internally by the bot.
*	  //TODO: Make decay times able to be changed in the config to be more
*		  or less harsh.
 */
func createIncident(u string, a string, i time.Time, e time.Duration, w string, p int) error {
	if w == "" {
		w = "No reason was provided"
	}

	eP := i.Add(e)
	//Decay is generated by the function 3âˆš(x^2) * 200 where X is
	//the length of the mute in hopefully minutes.
	decay := eP.Add((((e ^ 2) ^ (1 / 3)) * 200))

	log := incident{
		ID:     len(logs.Incidents),
		User:   u,
		Issuer: a,
		Time:   i.Format("2006-01-02@15:04:05"),
		Until:  eP.Format("2006-01-02@15:04:05"),
		Reason: w,
		Action: p,
		Decay:  decay.Format("2006-01-02@15:04:05"),
	}
	logs.Incidents = append(logs.Incidents, log)
	err := dat.Save("moderation"+ps+"logs.json", logs)
	if err != nil {
		dat.Log.Println(err)
		return err
	}
	return nil
}
